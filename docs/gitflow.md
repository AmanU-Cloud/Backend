## **GitHub Flow с Ветками**

Для эффективного управления разработкой проекта предлагается использовать **GitHub Flow** с определённой стратегией ветвления. Это позволит команде работать параллельно над различными задачами, обеспечит прозрачность процесса разработки и упростит интеграцию изменений в основную кодовую базу.

---

### **Стратегия Ветвления**

1. **Основная ветка (`main`)**

   * **Назначение:** Хранит стабильный, протестированный код, готовый к деплою.
   * **Правила:**

     * Прямые коммиты в `main` запрещены.
     * Изменения попадают в `main` только через Pull Request (PR) из `dev`, после релизной подготовки и прохождения всех проверок.
     * Вся новая разработка начинается от `main`.

2. **Ветка разработки (`dev`)**

   * **Назначение:** Интеграция функциональности перед релизом.
   * **Правила:**

     * В `dev` вливаются все фичи и багфиксы.
     * Регулярно обновляется от `main`.
     * Перед каждым релизом создаётся PR из `dev` в `main`.

3. **Фиче-ветки (`feature/NS-<номер-задачи>-краткое-описание`)**

   * **Назначение:** Разработка новой функциональности или исправление багов.
   * **Правила:**

     * Создаются от `main`.
     * После завершения работы создаётся PR для слияния в `dev`.
   * **Примеры:**

     * `feature/NS-1-создание-дома`
     * `feature/NS-3-реализация-регистрации`

4. **Hotfix-ветки (`hotfix/NS-<номер-задачи>-краткое-описание`)**

   * **Назначение:** Срочные исправления в `main`.
   * **Правила:**

     * Создаются от `main`.
     * После исправления вливаются обратно в `main` и `dev`.
   * **Пример:**

     * `hotfix/NS-105-исправление-авторизации`

---

### **Процесс Работы**

1. **Создание Фиче-ветки**

   ```bash
   git checkout main
   git pull origin main
   git checkout -b feature/NS-<номер-задачи>-описание
   ```

2. **Разработка и коммиты**

   ```bash
   git add .
   git commit -m "[NS-<номер>] Краткое описание изменений"
   ```

3. **Публикация ветки и PR в `dev`**

   ```bash
   git push origin feature/NS-<номер-задачи>-описание
   ```

   * PR: `feature/NH-...` → `dev`

---

### **Пример Рабочего Процесса**

**Разработчик Анна выполняет задачу NH-3: Реализация метода получения дома**

```bash
git checkout main
git pull origin main
git checkout -b feature/NS-3-получение-дома
# работа над кодом
git commit -m "[NH-3] Реализован метод GET /houses/{id}"
git push origin feature/NS-3-получение-дома
```

На GitHub создаётся PR из `feature/NS-3-получение-дома` в `dev`.

---

### **Релиз в `main`**

* После прохождения всех проверок и готовности релиза:

  ```bash
  git checkout dev
  git pull origin dev
  git checkout main
  git pull origin main
  git merge dev
  git push origin main
  ```

---

### **Hotfix-процесс**

```bash
git checkout main
git pull origin main
git checkout -b hotfix/NH-105-исправление-ошибки
# правки
git commit -m "[NH-105] Критическая ошибка авторизации исправлена"
git push origin hotfix/NH-105-исправление-ошибки
```

PR → в `main` и затем в `dev`.

---

### **Правила Именования и Коммитов**

* **Фиче-ветки:** `feature/NH-<номер-задачи>-описание`
* **Hotfix-ветки:** `hotfix/NH-<номер-задачи>-описание`
* **Коммиты:** `"[NH-<номер>] Краткое описание"`

---

### **Пример структуры репозитория**

```
main
dev
├── feature/NH-1-создание-дома
├── feature/NH-2-регистрация-пользователя
├── hotfix/NH-105-исправление-ошибки
```

---

### **Заключение**

Такой подход упрощает управление разработкой, релизами и обеспечивает чистую историю коммитов. Вся разработка начинается от `main`, рабочие изменения собираются в `dev`, а стабильные версии попадают в `main` после релиза.
